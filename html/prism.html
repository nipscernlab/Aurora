<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../node_modules/@fortawesome/fontawesome-free/css/all.css">
    <title>PRISM RTL Viewer</title>
    <style>
        :root {
            /* Modern Purple Palette */
            --purple-50: #faf7ff;
            --purple-100: #f3edff;
            --purple-200: #e6d7ff;
            --purple-300: #d4b8ff;
            --purple-400: #c084fc;
            --purple-500: #a855f7;
            --purple-600: #9333ea;
            --purple-700: #7c3aed;
            --purple-800: #6b21a8;
            --purple-900: #581c87;
            --purple-950: #3b0764;

            /* Dark Theme Optimized */
            --bg-primary: #0a0a0f;
            --bg-secondary: #121218;
            --bg-tertiary: #1a1a24;
            --bg-card: #242430;
            --bg-hover: #2d2d3e;
            --bg-glass: rgba(36, 36, 48, 0.8);
            
            --text-primary: #fafafa;
            --text-secondary: #d1d5db;
            --text-muted: #9ca3af;
            --text-accent: var(--purple-300);
            
            --border-primary: #374151;
            --border-accent: var(--purple-600);
            --border-highlight: var(--purple-400);
            
            --shadow-sm: 0 1px 3px rgba(168, 85, 247, 0.1);
            --shadow-md: 0 4px 12px rgba(168, 85, 247, 0.15);
            --shadow-lg: 0 10px 30px rgba(168, 85, 247, 0.2);
            --shadow-xl: 0 20px 50px rgba(168, 85, 247, 0.3);
            
            --gradient-primary: linear-gradient(135deg, var(--purple-600), var(--purple-700));
            --gradient-secondary: linear-gradient(135deg, var(--purple-500), var(--purple-600));
            --gradient-glass: linear-gradient(135deg, 
                rgba(168, 85, 247, 0.1), 
                rgba(124, 58, 237, 0.05));
            
            --transition-fast: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-smooth: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Reset and Base */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            font-size: 14px;
            line-height: 1.5;
        }

        /* Header */
        .header {
            background: var(--bg-glass);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--border-primary);
            padding: 12px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: var(--shadow-sm);
            z-index: 100;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 16px;
            font-weight: 700;
            color: var(--text-accent);
            letter-spacing: -0.025em;
        }

        .logo svg {
            width: 24px;
            height: 24px;
            fill: var(--purple-400);
        }

        .module-info {
            background: var(--bg-card);
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid var(--border-primary);
            backdrop-filter: blur(8px);
        }

        .module-name {
            font-weight: 600;
            font-size: 13px;
            color: var(--text-primary);
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .module-path {
            font-size: 11px;
            color: var(--text-muted);
            font-family: 'Fira Code', 'Courier New', monospace;
            max-width: 240px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin-top: 2px;
        }

        .header-controls {
            display: flex;
            gap: 8px;
        }

        /* Modern Buttons */
        .btn {
            padding: 8px 16px;
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition-fast);
            display: flex;
            align-items: center;
            gap: 6px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            text-decoration: none;
            outline: none;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: var(--gradient-glass);
            opacity: 0;
            transition: var(--transition-fast);
        }

        .btn:hover::before {
            opacity: 1;
        }

        .btn:hover {
            border-color: var(--border-accent);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .btn-primary {
            background: var(--gradient-primary);
            border-color: var(--purple-600);
            color: white;
            font-weight: 600;
        }

        .btn-primary:hover {
            background: var(--gradient-secondary);
            box-shadow: var(--shadow-lg);
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none !important;
        }

        .btn:disabled::before {
            opacity: 0 !important;
        }

        /* Breadcrumbs */
        .breadcrumbs-container {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
            position: relative;
        }

        .breadcrumbs {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 20px;
            overflow-x: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--purple-500) transparent;
            scroll-behavior: smooth;
        }

        .breadcrumbs::-webkit-scrollbar {
            height: 3px;
        }

        .breadcrumbs::-webkit-scrollbar-track {
            background: transparent;
        }

        .breadcrumbs::-webkit-scrollbar-thumb {
            background: var(--purple-500);
            border-radius: 2px;
        }

        .breadcrumb-item {
            color: var(--text-muted);
            cursor: pointer;
            transition: var(--transition-fast);
            padding: 4px 8px;
            border-radius: 6px;
            font-family: 'Fira Code', monospace;
            font-size: 12px;
            white-space: nowrap;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .breadcrumb-item:hover {
            color: var(--text-accent);
            background: var(--bg-hover);
        }

        .breadcrumb-item.active {
            color: var(--text-primary);
            font-weight: 600;
            background: var(--bg-card);
        }

        .breadcrumb-separator {
            color: var(--text-muted);
            opacity: 0.5;
            font-size: 10px;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }

        .svg-container {
            flex: 1;
            position: relative;
            background: var(--bg-primary);
            overflow: hidden;
            cursor: grab;
            margin: 8px;
            border-radius: 12px;
            border: 1px solid var(--border-primary);
            box-shadow: var(--shadow-lg);
        }

        .svg-container.dragging {
            cursor: grabbing;
        }

        .svg-wrapper {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            transform-origin: 0 0;
        }

        .svg-content {
            user-select: none;
            will-change: transform;
        }

        /* Enhanced SVG Styling */
        .svg-content svg {
            filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.2));
            border-radius: 8px;
        }

        
/* Estado inicial pré-carregamento: invisível e levemente reduzido */
.svg-content.fade-enter {
  opacity: 0;
  transform: scale(0.98);
}

/* Estado ativo de transição: visível e escala normal */
.svg-content.fade-enter-active {
  opacity: 1;
  transform: scale(1);
  transition: opacity 0.4s ease-in-out, transform 0.4s ease-in-out;
}

        .svg-content svg text {
            fill: var(--text-primary) !important;
            font-family: 'Inter', sans-serif !important;
            font-size: 10px !important;
            font-weight: 500 !important;
        }

        /* Module Rectangles with Modern Styling */
        .svg-content svg rect {
            stroke-width: 1.5 !important;
            rx: 8 !important;
            ry: 8 !important;
            transition: var(--transition-smooth);
            filter: drop-shadow(0 1px 3px rgba(0, 0, 0, 0.1));
        }

        .svg-content svg rect[fill="#ffffff"],
        .svg-content svg rect:not([fill]) {
            fill: var(--bg-card) !important;
            stroke: var(--purple-400) !important;
        }

        .svg-content svg rect[fill="#000000"] {
            fill: var(--bg-tertiary) !important;
            stroke: var(--purple-500) !important;
        }

        /* Wire Connections with Highlight Support */
        .svg-content svg path,
        .svg-content svg line {
            stroke: var(--purple-400) !important;
            stroke-width: 1.5 !important;
            fill: none !important;
            opacity: 0.7;
            transition: var(--transition-fast);
            cursor: pointer;
        }

        .svg-content svg path[stroke="#000000"],
        .svg-content svg line[stroke="#000000"] {
            stroke: var(--purple-300) !important;
        }

        /* Line Highlighting */
        .svg-content svg path.highlighted,
        .svg-content svg line.highlighted {
            stroke: var(--purple-200) !important;
            stroke-width: 3 !important;
            opacity: 1 !important;
            filter: drop-shadow(0 0 8px var(--purple-400)) !important;
            z-index: 10;
        }

        .svg-content svg path.connected,
        .svg-content svg line.connected {
            stroke: var(--purple-300) !important;
            stroke-width: 2 !important;
            opacity: 0.9 !important;
        }

:root {
  /* Tons de roxo principais. Ajuste conforme a paleta do seu projeto. */
  --module-fill: var(--purple-500, #8b5cf6);
  --module-stroke: var(--purple-400, #a78bfa);
  --module-text: var(--gray-900, #111827);

  /* Cores de hover. */
  --module-fill-hover: var(--purple-600, #7c3aed);
  --module-stroke-hover: var(--purple-300, #c4b5fd);
  --module-text-hover: #ffffff;

  /* Sombreamento no hover; você pode ajustar o RGBA para maior ou menor suavidade */
  --module-drop-shadow-hover: 0px 4px 12px rgba(168, 85, 247, 0.3);
}



/* 3. Estilo padrão dos elementos dentro do grupo */
.svg-content svg g.module rect,
.svg-content svg g[class*="module"] rect {
  fill: var(--module-fill);
  stroke: var(--module-stroke);
  stroke-width: 1;
  transition: fill 0.3s ease-in-out, stroke 0.3s ease-in-out, stroke-width 0.2s ease-in-out, filter 0.3s ease-in-out;
}

.svg-content svg g.module text,
.svg-content svg g[class*="module"] text {
  fill: var(--module-text);
  font-weight: 500;
  transition: fill 0.3s ease-in-out, font-weight 0.2s ease-in-out;
}



/* Texto em hover/focus */
.svg-content svg g.module:hover text,
.svg-content svg g[class*="module"]:hover text,
.svg-content svg g.module:focus-visible text,
.svg-content svg g[class*="module"]:focus-visible text {
  fill: var(--module-text-hover);
  font-weight: 600;
}

/* 5. Suporte a “prefers-reduced-motion” para usuários que pedem menos animação */
@media (prefers-reduced-motion: reduce) {
  .svg-content svg g.module,
  .svg-content svg g[class*="module"] {
    transition: none;
  }
  .svg-content svg g.module rect,
  .svg-content svg g[class*="module"] rect,
  .svg-content svg g.module text,
  .svg-content svg g[class*="module"] text {
    transition: none;
  }
}


        /* Ports */
        .svg-content svg circle {
            stroke: var(--purple-300) !important;
            stroke-width: 1.5 !important;
            transition: var(--transition-fast);
        }

        /* Zoom Controls */
        .zoom-controls {
            position: absolute;
            bottom: 16px;
            right: 16px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 50;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            border: 1px solid var(--border-primary);
            border-radius: 10px;
            background: var(--bg-glass);
            color: var(--text-primary);
            cursor: pointer;
            transition: var(--transition-fast);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: 600;
            box-shadow: var(--shadow-md);
            backdrop-filter: blur(12px);
        }

        .zoom-btn:hover {
            background: var(--purple-600);
            color: white;
            transform: scale(1.05);
            box-shadow: var(--shadow-lg);
        }

        /* Status Overlay */
        .status-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: var(--bg-glass);
            padding: 24px;
            border-radius: 16px;
            border: 1px solid var(--border-primary);
            box-shadow: var(--shadow-xl);
            backdrop-filter: blur(20px);
            z-index: 60;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border-primary);
            border-top: 3px solid var(--purple-500);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .status-text {
            font-size: 14px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .error-text {
            color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid #ef4444;
            font-size: 13px;
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            background: var(--bg-secondary);
            color: var(--text-primary);
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 12px;
            border: 1px solid var(--border-primary);
            box-shadow: var(--shadow-lg);
            pointer-events: none;
            z-index: 70;
            opacity: 0;
            transition: opacity 0.2s ease;
            backdrop-filter: blur(12px);
            font-weight: 500;
        }

        .tooltip.show {
            opacity: 1;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 12px;
                padding: 12px 16px;
            }

            .header-left {
                flex-direction: column;
                gap: 8px;
            }

            .zoom-controls {
                flex-direction: row;
                bottom: 12px;
                right: 12px;
            }

            .zoom-btn {
                width: 36px;
                height: 36px;
                font-size: 14px;
            }

            .svg-container {
                margin: 4px;
            }
        }

        /* Performance Optimizations */
        .svg-content svg * {
            vector-effect: non-scaling-stroke;
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Connection Highlighting Styles */
        .connection-group {
            transition: var(--transition-fast);
        }

        .connection-group.highlighted {
            filter: drop-shadow(0 0 12px var(--purple-400));
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--purple-500);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--purple-400);
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-left">
            <h1 class="logo">
               <img src="../assets/icons/prismv2.svg" style="width: 65px; height: inherit;">
                PRISM RTL Viewer
            </h1>
            <div class="module-info">
                <div class="module-name" id="currentModule">Loading...</div>
                <div class="module-path" id="currentPath">Preparing compilation...</div>
            </div>
        </div>
        <div class="header-controls">
            <button class="btn btn-back" id="backBtn" disabled>
                <i class="fa-solid fa-arrow-left"></i> Back
            </button>
            <button class="btn btn-secondary" id="fitBtn">
               <i class="fa-solid fa-compress"></i> Fit Screen
            </button>
            <button class="btn btn-primary" id="compileBtn">
                <i class="fa-solid fa-arrow-rotate-right"></i> Recompile
            </button>
        </div>
    </div>

    <div class="breadcrumbs-container">
        <div class="breadcrumbs" id="breadcrumbs"></div>
    </div>

    <div class="main-content">
        <div class="svg-container" id="svgContainer">
            <div class="svg-wrapper" id="svgWrapper">
                <div class="svg-content" id="svgContent"></div>
            </div>
            
            <div class="status-overlay" id="statusOverlay">
                <div class="loading-spinner"></div>
                <div class="status-text">Compiling RTL Design...</div>
            </div>

            <div class="zoom-controls">
                <button class="zoom-btn" id="zoomInBtn">+</button>
                <button class="zoom-btn" id="zoomOutBtn">−</button>
                <button class="zoom-btn" id="resetZoomBtn">⌂</button>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>
    <script>
        console.log('PRISM HTML script loading...');
console.log('window.electronAPI:', window.electronAPI);
console.log('window.electron:', window.electron);

// Wait for DOM and APIs to be available
document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM loaded - checking APIs again...');
    console.log('window.electronAPI:', window.electronAPI);
    console.log('window.electron:', window.electron);
    
    if (window.electronAPI) {
        console.log('electronAPI methods:', Object.keys(window.electronAPI));
    }
    
    if (window.electron) {
        console.log('electron methods:', Object.keys(window.electron));
    }
    
    // Fallback API setup if preload didn't work
    if (!window.electronAPI && !window.electron) {
        console.error('Neither electronAPI nor electron is available - preload script failed');
        
        // Create a dummy API to prevent crashes
        window.electronAPI = {
            compileForPRISM: () => {
                console.error('electronAPI not properly loaded');
                return Promise.reject(new Error('electronAPI not available'));
            },
            generateSVGFromModule: () => Promise.reject(new Error('electronAPI not available')),
            getAvailableModules: () => Promise.reject(new Error('electronAPI not available')),
            onCompilationComplete: () => console.error('electronAPI not available'),
            removeAllListeners: () => console.error('electronAPI not available')
        };
    }
});

       // 5. RENDERER PROCESS (prism.html) - Fixed PRISMViewer class constructor
class PRISMViewer {
    constructor() {
        this.currentScale = 1;
        this.currentX = 0;
        this.currentY = 0;
        this.isDragging = false;
        this.lastMouseX = 0;
        this.lastMouseY = 0;
        this.navigationHistory = [];
        this.currentModule = null;
        this.tempDir = null;
        this.isProjectOriented = false;
        
        this.initializeElements();
        this.setupEventListeners();
        
        // Don't start compilation immediately, wait for IPC message
        console.log('PRISMViewer initialized, waiting for compilation data...');
    }

    initializeElements() {
        this.svgContainer = document.getElementById('svgContainer');
        this.svgWrapper = document.getElementById('svgWrapper');
        this.svgContent = document.getElementById('svgContent');
        this.statusOverlay = document.getElementById('statusOverlay');
        this.currentModuleEl = document.getElementById('currentModule');
        this.currentPathEl = document.getElementById('currentPath');
        this.breadcrumbs = document.getElementById('breadcrumbs');
        this.backBtn = document.getElementById('backBtn');
        this.compileBtn = document.getElementById('compileBtn');
        this.fitBtn = document.getElementById('fitBtn');
        this.zoomInBtn = document.getElementById('zoomInBtn');
        this.zoomOutBtn = document.getElementById('zoomOutBtn');
        this.resetZoomBtn = document.getElementById('resetZoomBtn');
        this.tooltip = document.getElementById('tooltip');
    }

    setupEventListeners() {
        // Mouse events for pan and zoom
        this.svgContainer.addEventListener('mousedown', this.handleMouseDown.bind(this));
        this.svgContainer.addEventListener('mousemove', this.handleMouseMove.bind(this));
        this.svgContainer.addEventListener('mouseup', this.handleMouseUp.bind(this));
        this.svgContainer.addEventListener('wheel', this.handleWheel.bind(this));
        this.svgContainer.addEventListener('mouseleave', this.handleMouseUp.bind(this));

        // Button events
        this.backBtn.addEventListener('click', this.navigateBack.bind(this));
        this.compileBtn.addEventListener('click', this.recompile.bind(this));
        this.fitBtn.addEventListener('click', this.fitToScreen.bind(this));
        this.zoomInBtn.addEventListener('click', () => this.zoom(1.2));
        this.zoomOutBtn.addEventListener('click', () => this.zoom(0.8));
        this.resetZoomBtn.addEventListener('click', this.resetView.bind(this));

        // IPC events - FIXED
        if (window.electronAPI && window.electronAPI.onCompilationComplete) {
            window.electronAPI.onCompilationComplete(this.handleCompilationComplete.bind(this));
            console.log('Compilation complete listener registered');
        } else {
            console.error('electronAPI.onCompilationComplete not available');
        }
    }

            handleCompilationComplete(data) {
        console.log('Received compilation complete data:', data);
        
        if (data.success) {
            this.currentModule = data.topLevelModule;
            this.tempDir = data.tempDir;
            this.isProjectOriented = data.isProjectOriented;
            this.navigationHistory = [{
                module: data.topLevelModule,
                svgPath: data.svgPath
            }];
            
            console.log('Loading initial SVG:', data.svgPath);
            this.loadSVG(data.svgPath, data.topLevelModule);
        } else {
            this.showStatus(`Compilation Error: ${data.message}`, true);
        }
    }

           async loadSVG(svgPath, moduleName) {
    try {
        console.log('Loading SVG from:', svgPath);
        this.showStatus(`Loading ${moduleName}...`, false);

        // Use file:// protocol for local files
        const fileUrl = svgPath.startsWith('file://') ? svgPath : `file:///${svgPath.replace(/\\/g, '/')}`;
        console.log('File URL:', fileUrl);

        const response = await fetch(fileUrl);

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const svgText = await response.text();

        if (!svgText || !svgText.includes('<svg')) {
            throw new Error('Invalid SVG content received');
        }

        // --- INÍCIO: efeito de fade-in suave ---
        // 1. Garantir que o container esteja pronto para o efeito:
        // Remover classes antigas caso existam
        this.svgContent.classList.remove('fade-enter', 'fade-enter-active');

        // 2. Adicionar classe inicial (invisível, levemente reduzido)
        this.svgContent.classList.add('fade-enter');

        // 3. Inserir o conteúdo SVG
        this.svgContent.innerHTML = svgText;
        this.currentModule = moduleName;

        // 4. Forçar repaint antes de acionar a transição:
        //    usando requestAnimationFrame ou leitura de propriedade que força layout.
        requestAnimationFrame(() => {
            // Adicionar classe que contém a transição para opacidade 1 e scale(1)
            this.svgContent.classList.add('fade-enter-active');
            // Opcional: remover a classe inicial se quiser manter só a active
            // this.svgContent.classList.remove('fade-enter');
        });
        // --- FIM do efeito de fade-in ---

        // Seguir com as demais funcionalidades
        this.updateModuleInfo(moduleName, svgPath);
        this.updateBreadcrumbs();
        this.setupSVGInteractions();

        this.hideStatus();

        // Fit to screen após um breve delay (mantido)
        setTimeout(() => {
            this.fitToScreen();
        }, 100);

        console.log('SVG loaded successfully for module:', moduleName);

    } catch (error) {
        console.error('Failed to load SVG:', error);
        this.showStatus(`Failed to load SVG: ${error.message}`, true);
    }
}


    async navigateToModule(moduleName) {
        if (moduleName === this.currentModule || !this.tempDir) {
            console.log('Already on this module or no temp dir');
            return;
        }

        console.log(`Navigating to module: ${moduleName}`);
        this.showStatus(`Generating diagram for: ${moduleName}...`, false);
        
        try {
            // Generate SVG for the clicked module
            const result = await window.electronAPI.generateSVGFromModule(moduleName, this.tempDir);
            
            if (result.success) {
                // Add current state to history before navigating
                this.navigationHistory.push({
                    module: moduleName,
                    svgPath: result.svgPath
                });
                
                console.log('Generated SVG for module:', moduleName, 'at:', result.svgPath);
                await this.loadSVG(result.svgPath, moduleName);
                this.backBtn.disabled = false;
            } else {
                console.error('Failed to generate SVG for module:', moduleName, result.message);
                this.showStatus(`Module not found: ${moduleName}`, true);
                setTimeout(() => this.hideStatus(), 3000);
            }
        } catch (error) {
            console.error('Error navigating to module:', error);
            this.showStatus(`Error loading module: ${error.message}`, true);
            setTimeout(() => this.hideStatus(), 3000);
        }
    }

      // Enhanced setupSVGInteractions to include wire highlighting
setupSVGInteractions() {
    const svg = this.svgContent.querySelector('svg');
    if (!svg) {
        console.warn('No SVG found in content');
        return;
    }

    console.log('Setting up SVG interactions...');
    
    // Setup module clicking (existing functionality)
    const textElements = svg.querySelectorAll('text');
    textElements.forEach(textEl => {
        const textContent = textEl.textContent.trim();
        
        if (!textContent || 
            textContent.includes(':') || 
            textContent.includes('=') || 
            textContent.includes('[') ||
            textContent.includes('(') ||
            textContent.length < 2 ||
            textContent.match(/^\d+$/) ||
            textContent.includes('clk') ||
            textContent.includes('rst') ||
            textContent.includes('in') ||
            textContent.includes('out')) {
            return;
        }
        
        console.log('Found potential module:', textContent);
        this.setupModuleClick(textEl, textContent);
    });
    
    const groupElements = svg.querySelectorAll('g');
    groupElements.forEach(group => {
        const textEl = group.querySelector('text');
        if (textEl) {
            const textContent = textEl.textContent.trim();
            if (textContent && 
                !textContent.includes(':') && 
                !textContent.includes('=') &&
                textContent.length > 1) {
                this.setupModuleClick(group, textContent);
            }
        }
    });
    
    // Setup wire highlighting (new functionality)
    this.setupWireHighlighting();
}
setupModuleClick(element, moduleName) {
        element.style.cursor = 'pointer';
        element.classList.add('module-clickable');
        
        // Add visual feedback
        element.addEventListener('mouseenter', (e) => {
            element.style.opacity = '0.7';
            this.showTooltip(e, `Click to view module: ${moduleName}`);
        });

        element.addEventListener('mouseleave', () => {
            element.style.opacity = '1';
            this.hideTooltip();
        });
        
        element.addEventListener('click', async (e) => {
            e.stopPropagation();
            e.preventDefault();
            console.log('Module clicked:', moduleName);
            await this.navigateToModule(moduleName);
        });
    }

            navigateBack() {
                if (this.navigationHistory.length <= 1) return;

                // Remove current module from history
                this.navigationHistory.pop();
                
                // Get previous module
                const prevModule = this.navigationHistory[this.navigationHistory.length - 1];
                this.loadSVG(prevModule.svgPath, prevModule.module);
                
                // Disable back button if we're at the root
                if (this.navigationHistory.length <= 1) {
                    this.backBtn.disabled = true;
                }
            }

           // 10. RENDERER PROCESS - Enhanced recompile function
    async recompile() {
        console.log('Recompiling...');
        this.navigationHistory = [];
        this.backBtn.disabled = true;
        this.showStatus('Recompiling RTL Design...', false);
        
        try {
            const result = await window.electronAPI.compileForPRISM();
            if (!result.success) {
                this.showStatus(`Compilation Error: ${result.message}`, true);
            }
            // The handleCompilationComplete will be called automatically
        } catch (error) {
            console.error('Recompile error:', error);
            this.showStatus(`Compilation Failed: ${error.message}`, true);
        }
    }

    showStatus(message, isError = false) {
        const statusText = this.statusOverlay.querySelector('.status-text');
        const spinner = this.statusOverlay.querySelector('.loading-spinner');
        
        statusText.textContent = message;
        
        if (isError) {
            statusText.classList.add('error-text');
            spinner.style.display = 'none';
        } else {
            statusText.classList.remove('error-text');
            spinner.style.display = 'block';
        }
        
        this.statusOverlay.style.display = 'block';
        console.log('Status:', message, isError ? '(ERROR)' : '');
    }

    hideStatus() {
        this.statusOverlay.style.display = 'none';
    }

            updateModuleInfo(moduleName, svgPath) {
                this.currentModuleEl.textContent = moduleName;
                this.currentPathEl.textContent = svgPath;
            }

            updateBreadcrumbs() {
                this.breadcrumbs.innerHTML = '';
                
                this.navigationHistory.forEach((item, index) => {
                    if (index > 0) {
                        const separator = document.createElement('span');
                        separator.className = 'breadcrumb-separator';
                        separator.textContent = '→';
                        this.breadcrumbs.appendChild(separator);
                    }
                    
                    const breadcrumb = document.createElement('span');
                    breadcrumb.className = `breadcrumb-item ${index === this.navigationHistory.length - 1 ? 'active' : ''}`;
                    breadcrumb.textContent = item.module;
                    
                    if (index < this.navigationHistory.length - 1) {
                        breadcrumb.addEventListener('click', () => {
                            // Navigate to this level
                            this.navigationHistory = this.navigationHistory.slice(0, index + 1);
                            this.loadSVG(item.svgPath, item.module);
                            this.backBtn.disabled = this.navigationHistory.length <= 1;
                        });
                    }
                    
                    this.breadcrumbs.appendChild(breadcrumb);
                });
            }
handleMouseDown(e) {
    if (e.button !== 0) return; // só left-click

    const svg = this.svgContent.querySelector('svg');
    const clickInsideSvg = svg && svg.contains(e.target);

    // Marcar onde começou o drag
    this.draggingStartedInside = clickInsideSvg;

    if (!clickInsideSvg) {
        // Mousedown fora do SVG: limpa highlights imediatamente e não inicia drag
        this.clearWireHighlights();
        this.isDragging = false;
        return;
    }

    // Mousedown dentro do SVG: não limpar highlights, inicia panning
    this.isDragging = true;
    this.lastMouseX = e.clientX;
    this.lastMouseY = e.clientY;
    this.svgContainer.classList.add('dragging');
}

handleMouseMove(e) {
    if (this.isDragging) {
        const deltaX = e.clientX - this.lastMouseX;
        const deltaY = e.clientY - this.lastMouseY;

        this.currentX += deltaX;
        this.currentY += deltaY;

        this.updateTransform();

        this.lastMouseX = e.clientX;
        this.lastMouseY = e.clientY;
    }
}

handleMouseUp(e) {
    if (e.button !== 0) return;

    if (this.isDragging) {
        const svg = this.svgContent.querySelector('svg');
        const upTargetInside = svg && svg.contains(e.target);

        // Se o drag começou dentro mas o mouseup ocorrer fora do SVG: limpa highlights
        if (this.draggingStartedInside && !upTargetInside) {
            this.clearWireHighlights();
        }
    }
    // Finaliza panning em qualquer caso
    this.isDragging = false;
    this.svgContainer.classList.remove('dragging');
}

handleDocumentClick(e) {
    const svg = this.svgContent.querySelector('svg');
    if (!svg) return;
    // Se clicar fora do SVG, limpa highlights
    if (!svg.contains(e.target)) {
        this.clearWireHighlights();
    }
    // Se clicar dentro do SVG, não faz nada aqui (wire clicks ou outras interações
    // já tratam highlight; clique em fundo interno do SVG não limpa)
}
            // Enhanced zoom functionality with proper centering
handleWheel(e) {
    e.preventDefault();
    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
    this.zoom(zoomFactor, e.clientX, e.clientY);
}

zoom(factor, centerX = null, centerY = null) {
                const newScale = Math.max(0.1, Math.min(5, this.currentScale * factor));
                
                if (centerX !== null && centerY !== null) {
                    const rect = this.svgContainer.getBoundingClientRect();
                    const relativeX = centerX - rect.left;
                    const relativeY = centerY - rect.top;
                    
                    const scaleFactor = newScale / this.currentScale;
                    this.currentX = relativeX - (relativeX - this.currentX) * scaleFactor;
                    this.currentY = relativeY - (relativeY - this.currentY) * scaleFactor;
                }
                
                this.currentScale = newScale;
                this.updateTransform();
            }

            updateTransform() {
                this.svgWrapper.style.transform = `translate(${this.currentX}px, ${this.currentY}px) scale(${this.currentScale})`;
            }

            // Enhanced fit to screen with proper SVG bounds calculation
 fitToScreen() {
                const svg = this.svgContent.querySelector('svg');
                if (!svg) return;

                const containerRect = this.svgContainer.getBoundingClientRect();
                const svgRect = svg.getBoundingClientRect();
                
                const scaleX = (containerRect.width * 0.9) / svg.viewBox.baseVal.width;
                const scaleY = (containerRect.height * 0.9) / svg.viewBox.baseVal.height;
                
                this.currentScale = Math.min(scaleX, scaleY, 1);
                this.currentX = 0;
                this.currentY = 0;
                
                this.updateTransform();
            }

            resetView() {
                this.currentScale = 1;
                this.currentX = 0;
                this.currentY = 0;
                this.updateTransform();
            }

            showTooltip(e, text) {
                this.tooltip.textContent = text;
                this.tooltip.style.left = e.pageX + 10 + 'px';
                this.tooltip.style.top = e.pageY - 30 + 'px';
                this.tooltip.classList.add('show');
}


setupWireHighlighting() {
    const svg = this.svgContent.querySelector('svg');
    if (!svg) return;

    const wireElements = svg.querySelectorAll('path, line, polyline');

    wireElements.forEach(wire => {
        wire.style.cursor = 'pointer';
        wire.classList.add('wire-clickable');

        wire.addEventListener('click', (e) => {
            e.stopPropagation();
            this.highlightWireConnection(wire);
        });

        wire.addEventListener('mouseenter', (e) => {
            wire.style.strokeWidth = (parseFloat(wire.style.strokeWidth) || 1) * 1.5;
            this.showTooltip(e, 'Click to highlight connection');
        });

        wire.addEventListener('mouseleave', () => {
            if (!wire.classList.contains('highlighted')) {
                wire.style.strokeWidth = '';
            }
            this.hideTooltip();
        });
    });


    this.svgContainer.addEventListener('mousedown', this.handleMouseDown.bind(this));
    document.addEventListener('mousemove', this.handleMouseMove.bind(this));
    document.addEventListener('mouseup', this.handleMouseUp.bind(this));
    // Listener de clique global: limpa highlights se clicar fora do SVG
    document.addEventListener('click', this.handleDocumentClick.bind(this));
}


// Highlight wire connections and branches
highlightWireConnection(clickedWire) {
    const svg = this.svgContent.querySelector('svg');
    if (!svg) return;

    // Clear previous highlights
    this.clearWireHighlights();
    
    // Get connection points of clicked wire
    const connectionPoints = this.getWireConnectionPoints(clickedWire);
    
    // Find all connected wires
    const connectedWires = this.findConnectedWires(connectionPoints, svg);
    
    // Highlight all connected wires
    connectedWires.forEach(wire => {
        this.highlightWire(wire);
    });
    
    // Also highlight the original wire
    this.highlightWire(clickedWire);
    
    console.log(`Highlighted ${connectedWires.length + 1} connected wires`);
}

// Extract connection points from wire element
getWireConnectionPoints(wire) {
    const points = [];
    
    if (wire.tagName === 'path') {
        const pathData = wire.getAttribute('d');
        if (pathData) {
            // Parse path data to extract endpoints
            const pathCommands = pathData.match(/[MLHVCSQTAZ][^MLHVCSQTAZ]*/gi);
            if (pathCommands) {
                pathCommands.forEach(command => {
                    const coords = command.slice(1).trim().split(/[\s,]+/).map(n => parseFloat(n));
                    if (coords.length >= 2) {
                        points.push({ x: coords[coords.length - 2], y: coords[coords.length - 1] });
                    }
                });
            }
        }
    } else if (wire.tagName === 'line') {
        points.push(
            { x: parseFloat(wire.getAttribute('x1')), y: parseFloat(wire.getAttribute('y1')) },
            { x: parseFloat(wire.getAttribute('x2')), y: parseFloat(wire.getAttribute('y2')) }
        );
    } else if (wire.tagName === 'polyline') {
        const pointsAttr = wire.getAttribute('points');
        if (pointsAttr) {
            const coords = pointsAttr.trim().split(/[\s,]+/).map(n => parseFloat(n));
            for (let i = 0; i < coords.length; i += 2) {
                if (i + 1 < coords.length) {
                    points.push({ x: coords[i], y: coords[i + 1] });
                }
            }
        }
    }
    
    return points;
}

// Find all wires connected to given points
findConnectedWires(connectionPoints, svg) {
    const tolerance = 5; // pixels tolerance for connection detection
    const connectedWires = new Set();
    const allWires = svg.querySelectorAll('path, line, polyline');
    
    // Use iterative approach to find all connected wires
    const pointsToCheck = [...connectionPoints];
    const checkedWires = new Set();
    
    while (pointsToCheck.length > 0) {
        const currentPoint = pointsToCheck.pop();
        
        allWires.forEach(wire => {
            if (checkedWires.has(wire)) return;
            
            const wirePoints = this.getWireConnectionPoints(wire);
            const isConnected = wirePoints.some(wirePoint => 
                Math.abs(wirePoint.x - currentPoint.x) <= tolerance &&
                Math.abs(wirePoint.y - currentPoint.y) <= tolerance
            );
            
            if (isConnected) {
                connectedWires.add(wire);
                checkedWires.add(wire);
                // Add this wire's points to check for further connections
                wirePoints.forEach(point => {
                    if (!pointsToCheck.some(p => 
                        Math.abs(p.x - point.x) <= tolerance && 
                        Math.abs(p.y - point.y) <= tolerance
                    )) {
                        pointsToCheck.push(point);
                    }
                });
            }
        });
    }
    
    return Array.from(connectedWires);
}

// Apply highlight styling to wire
highlightWire(wire) {
    wire.classList.add('highlighted');
    const originalStroke = wire.getAttribute('stroke') || '#000000';
    const originalWidth = parseFloat(wire.getAttribute('stroke-width')) || 1;
    
    wire.style.stroke = '#ff4444';
    wire.style.strokeWidth = Math.max(originalWidth * 2, 3);
    wire.style.filter = 'drop-shadow(0 0 3px rgba(255, 68, 68, 0.8))';
    wire.style.zIndex = '1000';
    
    // Store original values for restoration
    wire.dataset.originalStroke = originalStroke;
    wire.dataset.originalStrokeWidth = originalWidth;
}

// Clear all wire highlights
clearWireHighlights() {
    const svg = this.svgContent.querySelector('svg');
    if (!svg) return;

    const highlightedWires = svg.querySelectorAll('.highlighted');
    highlightedWires.forEach(wire => {
        wire.classList.remove('highlighted');
        
        // Restore original styling
        if (wire.dataset.originalStroke) {
            wire.style.stroke = wire.dataset.originalStroke;
            delete wire.dataset.originalStroke;
        }
        if (wire.dataset.originalStrokeWidth) {
            wire.style.strokeWidth = wire.dataset.originalStrokeWidth;
            delete wire.dataset.originalStrokeWidth;
        } else {
            wire.style.strokeWidth = '';
        }
        
        wire.style.filter = '';
        wire.style.zIndex = '';
    });
}


            resetView() {
                this.currentScale = 1;
                this.currentX = 0;
                this.currentY = 0;
                this.updateTransform();
            }

            showTooltip(e, text) {
                this.tooltip.textContent = text;
                this.tooltip.style.left = e.pageX + 10 + 'px';
                this.tooltip.style.top = e.pageY - 30 + 'px';
                this.tooltip.classList.add('show');
}

            hideTooltip() {
                this.tooltip.classList.remove('show');
            }

            showStatus(message, isError = false) {
                const statusText = this.statusOverlay.querySelector('.status-text');
                const spinner = this.statusOverlay.querySelector('.loading-spinner');
                
                statusText.textContent = message;
                
                if (isError) {
                    statusText.classList.add('error-text');
                    spinner.style.display = 'none';
                } else {
                    statusText.classList.remove('error-text');
                    spinner.style.display = 'block';
                }
                
                this.statusOverlay.style.display = 'block';
            }

            hideStatus() {
                this.statusOverlay.style.display = 'none';
            }
        }

        // Preload API setup
        window.electronAPI = {
            compileForPRISM: () => window.electron.invoke('prism-compile'),
            generateSVGFromModule: (moduleName, tempDir) => 
                window.electron.invoke('generate-svg-from-module', moduleName, tempDir),
            getAvailableModules: (tempDir) => 
                window.electron.invoke('get-available-modules', tempDir),
            onCompilationComplete: (callback) => 
                window.electron.on('compilation-complete', (event, data) => callback(data))
        };

        // Initialize the PRISM Viewer when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new PRISMViewer();
        });

        // Add keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case '=':
                    case '+':
                        e.preventDefault();
                        document.getElementById('zoomInBtn').click();
                        break;
                    case '-':
                        e.preventDefault();
                        document.getElementById('zoomOutBtn').click();
                        break;
                    case '0':
                        e.preventDefault();
                        document.getElementById('resetZoomBtn').click();
                        break;
                    case 'f':
                        e.preventDefault();
                        document.getElementById('fitBtn').click();
                        break;
                    case 'r':
                        e.preventDefault();
                        document.getElementById('compileBtn').click();
                        break;
                }
            }
            
            // Escape key to go back
            if (e.key === 'Escape') {
                const backBtn = document.getElementById('backBtn');
                if (!backBtn.disabled) {
                    backBtn.click();
                }
            }
        });

        // Add context menu for additional options
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            
            // Create context menu if not exists
            let contextMenu = document.getElementById('contextMenu');
            if (!contextMenu) {
                contextMenu = document.createElement('div');
                contextMenu.id = 'contextMenu';
                contextMenu.className = 'context-menu';
                contextMenu.innerHTML = `
                    <div class="context-item" onclick="document.getElementById('fitBtn').click()">
                        <span>Fit to Screen</span>
                        <span class="shortcut">Ctrl+F</span>
                    </div>
                    <div class="context-item" onclick="document.getElementById('resetZoomBtn').click()">
                        <span>Reset Zoom</span>
                        <span class="shortcut">Ctrl+0</span>
                    </div>
                    <div class="context-separator"></div>
                    <div class="context-item" onclick="document.getElementById('compileBtn').click()">
                        <span>Recompile</span>
                        <span class="shortcut">Ctrl+R</span>
                    </div>
                `;
                document.body.appendChild(contextMenu);
                
                // Add context menu styles
                const contextStyle = document.createElement('style');
                contextStyle.textContent = `
                    .context-menu {
                        position: fixed;
                        background: var(--bg-secondary);
                        border: 1px solid var(--border-primary);
                        border-radius: var(--radius-md);
                        box-shadow: var(--shadow-lg);
                        z-index: var(--z-50);
                        min-width: 180px;
                        padding: var(--space-2);
                        display: none;
                    }
                    
                    .context-item {
                        padding: var(--space-2) var(--space-3);
                        cursor: pointer;
                        border-radius: var(--radius-sm);
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        font-size: var(--text-sm);
                        color: var(--text-primary);
                    }
                    
                    .context-item:hover {
                        background: var(--accent-primary);
                        color: white;
                    }
                    
                    .context-separator {
                        height: 1px;
                        background: var(--border-primary);
                        margin: var(--space-2) 0;
                    }
                    
                    .shortcut {
                        font-size: var(--text-xs);
                        color: var(--text-muted);
                        font-family: var(--font-mono);
                    }
                    
                    .context-item:hover .shortcut {
                        color: rgba(255, 255, 255, 0.8);
                    }
                `;
                document.head.appendChild(contextStyle);
            }
            
            // Position and show context menu
            contextMenu.style.left = e.pageX + 'px';
            contextMenu.style.top = e.pageY + 'px';
            contextMenu.style.display = 'block';
            
            // Hide context menu on click outside
            const hideContextMenu = (event) => {
                if (!contextMenu.contains(event.target)) {
                    contextMenu.style.display = 'none';
                    document.removeEventListener('click', hideContextMenu);
                }
            };
            
            setTimeout(() => {
                document.addEventListener('click', hideContextMenu);
            }, 10);
        });

        // Add mouse wheel zoom support with Ctrl key
        document.addEventListener('wheel', (e) => {
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                const viewer = window.prismViewer;
                if (viewer && viewer.handleWheel) {
                    viewer.handleWheel(e);
                }
            }
        }, { passive: false });

        // Store viewer instance globally for external access
        window.addEventListener('DOMContentLoaded', () => {
            window.prismViewer = new PRISMViewer();
        });

        // Add fullscreen support
        document.addEventListener('keydown', (e) => {
            if (e.key === 'F11') {
                e.preventDefault();
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                } else {
                    document.documentElement.requestFullscreen();
                }
            }
        });

        // Handle fullscreen changes
        document.addEventListener('fullscreenchange', () => {
            const viewer = window.prismViewer;
            if (viewer) {
                // Recalculate fit to screen when entering/exiting fullscreen
                setTimeout(() => {
                    viewer.fitToScreen();
                }, 100);
            }
        });

        // Add window resize handler
        window.addEventListener('resize', () => {
            const viewer = window.prismViewer;
            if (viewer) {
                // Debounce resize handling
                clearTimeout(viewer.resizeTimeout);
                viewer.resizeTimeout = setTimeout(() => {
                    viewer.fitToScreen();
                }, 250);
            }
        });

        // Add performance monitoring
        window.addEventListener('load', () => {
            console.log('PRISM Viewer loaded in', performance.now().toFixed(2), 'ms');
            
            // Monitor performance
            if ('PerformanceObserver' in window) {
                const observer = new PerformanceObserver((list) => {
                    const entries = list.getEntries();
                    entries.forEach((entry) => {
                        if (entry.duration > 100) {
                            console.warn(`Slow operation detected: ${entry.name} took ${entry.duration.toFixed(2)}ms`);
                        }
                    });
                });
                
                observer.observe({ entryTypes: ['measure', 'navigation'] });
            }
        });

        // Add error boundary for uncaught errors
        window.addEventListener('error', (e) => {
            console.error('Uncaught error in PRISM Viewer:', e.error);
            
            // Show user-friendly error message
            const viewer = window.prismViewer;
            if (viewer) {
                viewer.showStatus(`Application Error: ${e.error.message}`, true);
            }
        });

        // Add unhandled promise rejection handler
        window.addEventListener('unhandledrejection', (e) => {
            console.error('Unhandled promise rejection in PRISM Viewer:', e.reason);
            
            const viewer = window.prismViewer;
            if (viewer) {
                viewer.showStatus(`Promise Error: ${e.reason}`, true);
            }
        });
    </script>
</body>
</html>