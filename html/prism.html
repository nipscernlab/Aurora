<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PRISM RTL Viewer</title>
    <link rel="stylesheet" href="../css/themeVariables.css">
    <style>
        :root {
            /* Purple Palette */
            --purple-50: #faf5ff;
            --purple-100: #f3e8ff;
            --purple-200: #e9d5ff;
            --purple-300: #d8b4fe;
            --purple-400: #c084fc;
            --purple-500: #a855f7;
            --purple-600: #9333ea;
            --purple-700: #7c3aed;
            --purple-800: #6b21a8;
            --purple-900: #581c87;

            /* Dark Theme */
            --bg-primary: #0f0f23;
            --bg-secondary: #1a1a3a;
            --bg-tertiary: #242449;
            --bg-card: #2d2d52;
            --bg-hover: #34345a;
            
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;
            
            --border: #374151;
            --shadow: 0 2px 8px rgba(168, 85, 247, 0.1);
            --shadow-lg: 0 10px 25px rgba(168, 85, 247, 0.2);
            
            --transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            padding: 0.75rem 1.25rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            backdrop-filter: blur(12px);
            box-shadow: var(--shadow);
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 1.25rem;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--purple-300);
        }

        .logo i {
            color: var(--purple-400);
            font-size: 1.2rem;
        }

        .module-info {
            background: var(--bg-card);
            padding: 0.4rem 0.8rem;
            border-radius: 6px;
            border: 1px solid var(--border);
        }

        .module-name {
            font-weight: 600;
            font-size: 0.85rem;
            max-width: 180px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .module-path {
            font-size: 0.7rem;
            color: var(--text-muted);
            font-family: 'Courier New', monospace;
            max-width: 220px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .header-controls {
            display: flex;
            gap: 0.6rem;
        }

        /* Buttons */
        .btn {
            padding: 0.5rem 1rem;
            border: 1px solid var(--border);
            border-radius: 5px;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 0.4rem;
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .btn:hover {
            border-color: var(--purple-400);
            background: var(--bg-hover);
            transform: translateY(-1px);
            box-shadow: var(--shadow);
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--purple-600), var(--purple-700));
            border-color: var(--purple-600);
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, var(--purple-500), var(--purple-600));
            box-shadow: var(--shadow-lg);
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none !important;
        }

        /* Breadcrumbs with Scroll */
        .breadcrumbs-container {
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
            position: relative;
            overflow: hidden;
        }

        .breadcrumbs {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.6rem 3rem 0.6rem 1.25rem;
            overflow-x: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--purple-500) transparent;
            scroll-behavior: smooth;
        }

        .breadcrumbs::-webkit-scrollbar {
            height: 4px;
        }

        .breadcrumbs::-webkit-scrollbar-track {
            background: transparent;
        }

        .breadcrumbs::-webkit-scrollbar-thumb {
            background: var(--purple-500);
            border-radius: 2px;
        }

        .breadcrumb-item {
            color: var(--text-muted);
            cursor: pointer;
            transition: var(--transition);
            padding: 0.3rem 0.6rem;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            white-space: nowrap;
            max-width: 100px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .breadcrumb-item:hover {
            color: var(--purple-300);
            background: var(--bg-hover);
        }

        .breadcrumb-item.active {
            color: var(--text-primary);
            font-weight: 600;
            background: var(--bg-card);
        }

        .breadcrumb-separator {
            color: var(--text-muted);
            opacity: 0.5;
            font-size: 0.7rem;
        }

        .scroll-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: var(--transition);
            z-index: 10;
            font-size: 0.75rem;
        }

        .scroll-arrow:hover {
            background: var(--purple-600);
            color: white;
        }

        .scroll-left { left: 0.4rem; }
        .scroll-right { right: 0.4rem; }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }

        .svg-container {
            flex: 1;
            position: relative;
            background: var(--bg-primary);
            overflow: hidden;
            cursor: grab;
            margin: 0.6rem;
            border-radius: 8px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow-lg);
        }

        .svg-container.dragging {
            cursor: grabbing;
        }

        .svg-wrapper {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s ease;
        }

        .svg-content {
            user-select: none;
        }

        /* Enhanced SVG Styling */
        .svg-content svg {
            filter: drop-shadow(0 1px 3px rgba(0, 0, 0, 0.3));
        }

        .svg-content svg text {
            fill: var(--text-primary) !important;
            font-family: 'Segoe UI', sans-serif !important;
            font-size: 8px !important;
            font-weight: 500 !important;
        }

        /* Module Rectangles */
        .svg-content svg rect {
            stroke-width: 1.2 !important;
            rx: 6 !important;
            ry: 6 !important;
            transition: var(--transition);
        }

        .svg-content svg rect[fill="#ffffff"],
        .svg-content svg rect:not([fill]) {
            fill: var(--bg-card) !important;
            stroke: var(--purple-400) !important;
        }

        .svg-content svg rect[fill="#000000"] {
            fill: var(--bg-tertiary) !important;
            stroke: var(--purple-500) !important;
        }

        /* Wire Connections */
        .svg-content svg path,
        .svg-content svg line {
            stroke: var(--purple-400) !important;
            stroke-width: 1 !important;
            fill: none !important;
            opacity: 0.7;
        }

        .svg-content svg path[stroke="#000000"],
        .svg-content svg line[stroke="#000000"] {
            stroke: var(--purple-300) !important;
        }

        /* Module Hover Effects */
        .svg-content svg g.module:hover rect,
        .svg-content svg g[class*="module"]:hover rect {
            fill: var(--purple-600) !important;
            stroke: var(--purple-300) !important;
            stroke-width: 1.5 !important;
            filter: drop-shadow(0 2px 8px rgba(168, 85, 247, 0.4));
        }

        .svg-content svg g.module:hover text,
        .svg-content svg g[class*="module"]:hover text {
            fill: white !important;
            font-weight: 600 !important;
        }

        /* Ports */
        .svg-content svg circle {
            /*fill: var(--purple-500) !important;*/
            stroke: var(--purple-300) !important;
            stroke-width: 1 !important;
            transition: var(--transition);
        }

        .svg-content svg circle:hover {
            fill: var(--purple-400) !important;
            transform: scale(1.1);
        }

        /* Zoom Controls */
        .zoom-controls {
            position: absolute;
            bottom: 0.8rem;
            right: 0.8rem;
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
            z-index: 40;
        }

        .zoom-btn {
            width: 36px;
            height: 36px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--bg-card);
            color: var(--text-primary);
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            box-shadow: var(--shadow);
            backdrop-filter: blur(8px);
        }

        .zoom-btn:hover {
            background: var(--purple-600);
            color: white;
            transform: scale(1.05);
        }

        /* Status Overlay */
        .status-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: var(--bg-card);
            padding: 1.5rem;
            border-radius: 8px;
            border: 1px solid var(--border);
            box-shadow: var(--shadow-lg);
            backdrop-filter: blur(16px);
        }

        .loading-spinner {
            width: 32px;
            height: 32px;
            border: 2px solid var(--border);
            border-top: 2px solid var(--purple-500);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 0.8rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .status-text {
            font-size: 0.9rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .error-text {
            color: #ef4444;
            background: #2d0a0a;
            padding: 0.6rem 0.8rem;
            border-radius: 6px;
            border: 1px solid #ef4444;
            margin-top: 0.8rem;
            font-size: 0.85rem;
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            background: var(--bg-secondary);
            color: var(--text-primary);
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            font-size: 0.8rem;
            border: 1px solid var(--border);
            box-shadow: var(--shadow-lg);
            pointer-events: none;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.2s ease;
            backdrop-filter: blur(8px);
        }

        .tooltip.show {
            opacity: 1;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 0.8rem;
                padding: 0.8rem;
            }

            .header-left {
                flex-direction: column;
                gap: 0.6rem;
            }

            .zoom-controls {
                flex-direction: row;
                bottom: 0.5rem;
                right: 0.5rem;
            }

            .zoom-btn {
                width: 32px;
                height: 32px;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-left">
            <h1 class="header-title"> <img src="../assets/icons/prism.svg" style="width: 26px; height: inherit;"> PRISM RTL Viewer</h1>
            <div class="module-info">
                <div class="module-name" id="currentModule">Loading...</div>
                <div class="module-path" id="currentPath">Preparing compilation...</div>
            </div>
        </div>
        <div class="header-controls">
            <button class="btn btn-back" id="backBtn" disabled>
                ← Back
            </button>
            <button class="btn btn-secondary" id="fitBtn">
                Fit to Screen
            </button>
            <button class="btn btn-primary" id="compileBtn">
                Recompile
            </button>
        </div>
    </div>

    <div class="breadcrumbs" id="breadcrumbs"></div>

    <div class="main-content">
        <div class="svg-container" id="svgContainer">
            <div class="svg-wrapper" id="svgWrapper">
                <div class="svg-content" id="svgContent"></div>
            </div>
            
            <div class="status-overlay" id="statusOverlay">
                <div class="loading-spinner"></div>
                <div class="status-text">Compiling RTL Design...</div>
            </div>

            <div class="zoom-controls">
                <button class="zoom-btn" id="zoomInBtn">+</button>
                <button class="zoom-btn" id="zoomOutBtn">−</button>
                <button class="zoom-btn" id="resetZoomBtn">⌂</button>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        console.log('PRISM HTML script loading...');
console.log('window.electronAPI:', window.electronAPI);
console.log('window.electron:', window.electron);

// Wait for DOM and APIs to be available
document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM loaded - checking APIs again...');
    console.log('window.electronAPI:', window.electronAPI);
    console.log('window.electron:', window.electron);
    
    if (window.electronAPI) {
        console.log('electronAPI methods:', Object.keys(window.electronAPI));
    }
    
    if (window.electron) {
        console.log('electron methods:', Object.keys(window.electron));
    }
    
    // Fallback API setup if preload didn't work
    if (!window.electronAPI && !window.electron) {
        console.error('Neither electronAPI nor electron is available - preload script failed');
        
        // Create a dummy API to prevent crashes
        window.electronAPI = {
            compileForPRISM: () => {
                console.error('electronAPI not properly loaded');
                return Promise.reject(new Error('electronAPI not available'));
            },
            generateSVGFromModule: () => Promise.reject(new Error('electronAPI not available')),
            getAvailableModules: () => Promise.reject(new Error('electronAPI not available')),
            onCompilationComplete: () => console.error('electronAPI not available'),
            removeAllListeners: () => console.error('electronAPI not available')
        };
    }
});

       // 5. RENDERER PROCESS (prism.html) - Fixed PRISMViewer class constructor
class PRISMViewer {
    constructor() {
        this.currentScale = 1;
        this.currentX = 0;
        this.currentY = 0;
        this.isDragging = false;
        this.lastMouseX = 0;
        this.lastMouseY = 0;
        this.navigationHistory = [];
        this.currentModule = null;
        this.tempDir = null;
        this.isProjectOriented = false;
        
        this.initializeElements();
        this.setupEventListeners();
        
        // Don't start compilation immediately, wait for IPC message
        console.log('PRISMViewer initialized, waiting for compilation data...');
    }

    initializeElements() {
        this.svgContainer = document.getElementById('svgContainer');
        this.svgWrapper = document.getElementById('svgWrapper');
        this.svgContent = document.getElementById('svgContent');
        this.statusOverlay = document.getElementById('statusOverlay');
        this.currentModuleEl = document.getElementById('currentModule');
        this.currentPathEl = document.getElementById('currentPath');
        this.breadcrumbs = document.getElementById('breadcrumbs');
        this.backBtn = document.getElementById('backBtn');
        this.compileBtn = document.getElementById('compileBtn');
        this.fitBtn = document.getElementById('fitBtn');
        this.zoomInBtn = document.getElementById('zoomInBtn');
        this.zoomOutBtn = document.getElementById('zoomOutBtn');
        this.resetZoomBtn = document.getElementById('resetZoomBtn');
        this.tooltip = document.getElementById('tooltip');
    }

    setupEventListeners() {
        // Mouse events for pan and zoom
        this.svgContainer.addEventListener('mousedown', this.handleMouseDown.bind(this));
        this.svgContainer.addEventListener('mousemove', this.handleMouseMove.bind(this));
        this.svgContainer.addEventListener('mouseup', this.handleMouseUp.bind(this));
        this.svgContainer.addEventListener('wheel', this.handleWheel.bind(this));
        this.svgContainer.addEventListener('mouseleave', this.handleMouseUp.bind(this));

        // Button events
        this.backBtn.addEventListener('click', this.navigateBack.bind(this));
        this.compileBtn.addEventListener('click', this.recompile.bind(this));
        this.fitBtn.addEventListener('click', this.fitToScreen.bind(this));
        this.zoomInBtn.addEventListener('click', () => this.zoom(1.2));
        this.zoomOutBtn.addEventListener('click', () => this.zoom(0.8));
        this.resetZoomBtn.addEventListener('click', this.resetView.bind(this));

        // IPC events - FIXED
        if (window.electronAPI && window.electronAPI.onCompilationComplete) {
            window.electronAPI.onCompilationComplete(this.handleCompilationComplete.bind(this));
            console.log('Compilation complete listener registered');
        } else {
            console.error('electronAPI.onCompilationComplete not available');
        }
    }

            handleCompilationComplete(data) {
        console.log('Received compilation complete data:', data);
        
        if (data.success) {
            this.currentModule = data.topLevelModule;
            this.tempDir = data.tempDir;
            this.isProjectOriented = data.isProjectOriented;
            this.navigationHistory = [{
                module: data.topLevelModule,
                svgPath: data.svgPath
            }];
            
            console.log('Loading initial SVG:', data.svgPath);
            this.loadSVG(data.svgPath, data.topLevelModule);
        } else {
            this.showStatus(`Compilation Error: ${data.message}`, true);
        }
    }

           async loadSVG(svgPath, moduleName) {
        try {
            console.log('Loading SVG from:', svgPath);
            this.showStatus(`Loading ${moduleName}...`, false);
            
            // Use file:// protocol for local files
            const fileUrl = svgPath.startsWith('file://') ? svgPath : `file:///${svgPath.replace(/\\/g, '/')}`;
            console.log('File URL:', fileUrl);
            
            const response = await fetch(fileUrl);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const svgText = await response.text();
            
            if (!svgText || !svgText.includes('<svg')) {
                throw new Error('Invalid SVG content received');
            }
            
            this.svgContent.innerHTML = svgText;
            this.currentModule = moduleName;
            
            this.updateModuleInfo(moduleName, svgPath);
            this.updateBreadcrumbs();
            this.setupSVGInteractions();
            
            this.hideStatus();
            
            // Fit to screen after a short delay
            setTimeout(() => {
                this.fitToScreen();
            }, 100);
            
            console.log('SVG loaded successfully for module:', moduleName);
            
        } catch (error) {
            console.error('Failed to load SVG:', error);
            this.showStatus(`Failed to load SVG: ${error.message}`, true);
        }
    }

    async navigateToModule(moduleName) {
        if (moduleName === this.currentModule || !this.tempDir) {
            console.log('Already on this module or no temp dir');
            return;
        }

        console.log(`Navigating to module: ${moduleName}`);
        this.showStatus(`Generating diagram for: ${moduleName}...`, false);
        
        try {
            // Generate SVG for the clicked module
            const result = await window.electronAPI.generateSVGFromModule(moduleName, this.tempDir);
            
            if (result.success) {
                // Add current state to history before navigating
                this.navigationHistory.push({
                    module: moduleName,
                    svgPath: result.svgPath
                });
                
                console.log('Generated SVG for module:', moduleName, 'at:', result.svgPath);
                await this.loadSVG(result.svgPath, moduleName);
                this.backBtn.disabled = false;
            } else {
                console.error('Failed to generate SVG for module:', moduleName, result.message);
                this.showStatus(`Module not found: ${moduleName}`, true);
                setTimeout(() => this.hideStatus(), 3000);
            }
        } catch (error) {
            console.error('Error navigating to module:', error);
            this.showStatus(`Error loading module: ${error.message}`, true);
            setTimeout(() => this.hideStatus(), 3000);
        }
    }

           setupSVGInteractions() {
        const svg = this.svgContent.querySelector('svg');
        if (!svg) {
            console.warn('No SVG found in content');
            return;
        }

        console.log('Setting up SVG interactions...');
        
        // Find all text elements that might be module names
        const textElements = svg.querySelectorAll('text');
        
        textElements.forEach(textEl => {
            const textContent = textEl.textContent.trim();
            
            // Skip empty text, ports, and other non-module text
            if (!textContent || 
                textContent.includes(':') || 
                textContent.includes('=') || 
                textContent.includes('[') ||
                textContent.includes('(') ||
                textContent.length < 2 ||
                textContent.match(/^\d+$/) || // Skip pure numbers
                textContent.includes('clk') ||
                textContent.includes('rst') ||
                textContent.includes('in') ||
                textContent.includes('out')) {
                return;
            }
            
            console.log('Found potential module:', textContent);
            this.setupModuleClick(textEl, textContent);
        });
        
        // Also check for group elements that might contain modules
        const groupElements = svg.querySelectorAll('g');
        groupElements.forEach(group => {
            const textEl = group.querySelector('text');
            if (textEl) {
                const textContent = textEl.textContent.trim();
                if (textContent && 
                    !textContent.includes(':') && 
                    !textContent.includes('=') &&
                    textContent.length > 1) {
                    this.setupModuleClick(group, textContent);
                }
            }
        });
    }
setupModuleClick(element, moduleName) {
        element.style.cursor = 'pointer';
        element.classList.add('module-clickable');
        
        // Add visual feedback
        element.addEventListener('mouseenter', (e) => {
            element.style.opacity = '0.7';
            this.showTooltip(e, `Click to view module: ${moduleName}`);
        });

        element.addEventListener('mouseleave', () => {
            element.style.opacity = '1';
            this.hideTooltip();
        });
        
        element.addEventListener('click', async (e) => {
            e.stopPropagation();
            e.preventDefault();
            console.log('Module clicked:', moduleName);
            await this.navigateToModule(moduleName);
        });
    }

            navigateBack() {
                if (this.navigationHistory.length <= 1) return;

                // Remove current module from history
                this.navigationHistory.pop();
                
                // Get previous module
                const prevModule = this.navigationHistory[this.navigationHistory.length - 1];
                this.loadSVG(prevModule.svgPath, prevModule.module);
                
                // Disable back button if we're at the root
                if (this.navigationHistory.length <= 1) {
                    this.backBtn.disabled = true;
                }
            }

           // 10. RENDERER PROCESS - Enhanced recompile function
    async recompile() {
        console.log('Recompiling...');
        this.navigationHistory = [];
        this.backBtn.disabled = true;
        this.showStatus('Recompiling RTL Design...', false);
        
        try {
            const result = await window.electronAPI.compileForPRISM();
            if (!result.success) {
                this.showStatus(`Compilation Error: ${result.message}`, true);
            }
            // The handleCompilationComplete will be called automatically
        } catch (error) {
            console.error('Recompile error:', error);
            this.showStatus(`Compilation Failed: ${error.message}`, true);
        }
    }

    showStatus(message, isError = false) {
        const statusText = this.statusOverlay.querySelector('.status-text');
        const spinner = this.statusOverlay.querySelector('.loading-spinner');
        
        statusText.textContent = message;
        
        if (isError) {
            statusText.classList.add('error-text');
            spinner.style.display = 'none';
        } else {
            statusText.classList.remove('error-text');
            spinner.style.display = 'block';
        }
        
        this.statusOverlay.style.display = 'block';
        console.log('Status:', message, isError ? '(ERROR)' : '');
    }

    hideStatus() {
        this.statusOverlay.style.display = 'none';
    }

            updateModuleInfo(moduleName, svgPath) {
                this.currentModuleEl.textContent = moduleName;
                this.currentPathEl.textContent = svgPath;
            }

            updateBreadcrumbs() {
                this.breadcrumbs.innerHTML = '';
                
                this.navigationHistory.forEach((item, index) => {
                    if (index > 0) {
                        const separator = document.createElement('span');
                        separator.className = 'breadcrumb-separator';
                        separator.textContent = '→';
                        this.breadcrumbs.appendChild(separator);
                    }
                    
                    const breadcrumb = document.createElement('span');
                    breadcrumb.className = `breadcrumb-item ${index === this.navigationHistory.length - 1 ? 'active' : ''}`;
                    breadcrumb.textContent = item.module;
                    
                    if (index < this.navigationHistory.length - 1) {
                        breadcrumb.addEventListener('click', () => {
                            // Navigate to this level
                            this.navigationHistory = this.navigationHistory.slice(0, index + 1);
                            this.loadSVG(item.svgPath, item.module);
                            this.backBtn.disabled = this.navigationHistory.length <= 1;
                        });
                    }
                    
                    this.breadcrumbs.appendChild(breadcrumb);
                });
            }

            // Pan and Zoom functionality
            handleMouseDown(e) {
                if (e.button === 0) { // Left click
                    this.isDragging = true;
                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;
                    this.svgContainer.classList.add('dragging');
                }
            }

            handleMouseMove(e) {
                if (this.isDragging) {
                    const deltaX = e.clientX - this.lastMouseX;
                    const deltaY = e.clientY - this.lastMouseY;
                    
                    this.currentX += deltaX;
                    this.currentY += deltaY;
                    
                    this.updateTransform();
                    
                    this.lastMouseX = e.clientX;
                    this.lastMouseY = e.clientY;
                }
            }

            handleMouseUp() {
                this.isDragging = false;
                this.svgContainer.classList.remove('dragging');
            }

            handleWheel(e) {
                e.preventDefault();
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                this.zoom(zoomFactor, e.clientX, e.clientY);
            }

            zoom(factor, centerX = null, centerY = null) {
                const newScale = Math.max(0.1, Math.min(5, this.currentScale * factor));
                
                if (centerX !== null && centerY !== null) {
                    const rect = this.svgContainer.getBoundingClientRect();
                    const relativeX = centerX - rect.left;
                    const relativeY = centerY - rect.top;
                    
                    const scaleFactor = newScale / this.currentScale;
                    this.currentX = relativeX - (relativeX - this.currentX) * scaleFactor;
                    this.currentY = relativeY - (relativeY - this.currentY) * scaleFactor;
                }
                
                this.currentScale = newScale;
                this.updateTransform();
            }

            updateTransform() {
                this.svgWrapper.style.transform = `translate(${this.currentX}px, ${this.currentY}px) scale(${this.currentScale})`;
            }

            fitToScreen() {
                const svg = this.svgContent.querySelector('svg');
                if (!svg) return;

                const containerRect = this.svgContainer.getBoundingClientRect();
                const svgRect = svg.getBoundingClientRect();
                
                const scaleX = (containerRect.width * 0.9) / svg.viewBox.baseVal.width;
                const scaleY = (containerRect.height * 0.9) / svg.viewBox.baseVal.height;
                
                this.currentScale = Math.min(scaleX, scaleY, 1);
                this.currentX = 0;
                this.currentY = 0;
                
                this.updateTransform();
            }

            resetView() {
                this.currentScale = 1;
                this.currentX = 0;
                this.currentY = 0;
                this.updateTransform();
            }

            showTooltip(e, text) {
                this.tooltip.textContent = text;
                this.tooltip.style.left = e.pageX + 10 + 'px';
                this.tooltip.style.top = e.pageY - 30 + 'px';
                this.tooltip.classList.add('show');
}

            hideTooltip() {
                this.tooltip.classList.remove('show');
            }

            showStatus(message, isError = false) {
                const statusText = this.statusOverlay.querySelector('.status-text');
                const spinner = this.statusOverlay.querySelector('.loading-spinner');
                
                statusText.textContent = message;
                
                if (isError) {
                    statusText.classList.add('error-text');
                    spinner.style.display = 'none';
                } else {
                    statusText.classList.remove('error-text');
                    spinner.style.display = 'block';
                }
                
                this.statusOverlay.style.display = 'block';
            }

            hideStatus() {
                this.statusOverlay.style.display = 'none';
            }
        }

        // Preload API setup
        window.electronAPI = {
            compileForPRISM: () => window.electron.invoke('prism-compile'),
            generateSVGFromModule: (moduleName, tempDir) => 
                window.electron.invoke('generate-svg-from-module', moduleName, tempDir),
            getAvailableModules: (tempDir) => 
                window.electron.invoke('get-available-modules', tempDir),
            onCompilationComplete: (callback) => 
                window.electron.on('compilation-complete', (event, data) => callback(data))
        };

        // Initialize the PRISM Viewer when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            new PRISMViewer();
        });

        // Add keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case '=':
                    case '+':
                        e.preventDefault();
                        document.getElementById('zoomInBtn').click();
                        break;
                    case '-':
                        e.preventDefault();
                        document.getElementById('zoomOutBtn').click();
                        break;
                    case '0':
                        e.preventDefault();
                        document.getElementById('resetZoomBtn').click();
                        break;
                    case 'f':
                        e.preventDefault();
                        document.getElementById('fitBtn').click();
                        break;
                    case 'r':
                        e.preventDefault();
                        document.getElementById('compileBtn').click();
                        break;
                }
            }
            
            // Escape key to go back
            if (e.key === 'Escape') {
                const backBtn = document.getElementById('backBtn');
                if (!backBtn.disabled) {
                    backBtn.click();
                }
            }
        });

        // Add context menu for additional options
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            
            // Create context menu if not exists
            let contextMenu = document.getElementById('contextMenu');
            if (!contextMenu) {
                contextMenu = document.createElement('div');
                contextMenu.id = 'contextMenu';
                contextMenu.className = 'context-menu';
                contextMenu.innerHTML = `
                    <div class="context-item" onclick="document.getElementById('fitBtn').click()">
                        <span>Fit to Screen</span>
                        <span class="shortcut">Ctrl+F</span>
                    </div>
                    <div class="context-item" onclick="document.getElementById('resetZoomBtn').click()">
                        <span>Reset Zoom</span>
                        <span class="shortcut">Ctrl+0</span>
                    </div>
                    <div class="context-separator"></div>
                    <div class="context-item" onclick="document.getElementById('compileBtn').click()">
                        <span>Recompile</span>
                        <span class="shortcut">Ctrl+R</span>
                    </div>
                `;
                document.body.appendChild(contextMenu);
                
                // Add context menu styles
                const contextStyle = document.createElement('style');
                contextStyle.textContent = `
                    .context-menu {
                        position: fixed;
                        background: var(--bg-secondary);
                        border: 1px solid var(--border-primary);
                        border-radius: var(--radius-md);
                        box-shadow: var(--shadow-lg);
                        z-index: var(--z-50);
                        min-width: 180px;
                        padding: var(--space-2);
                        display: none;
                    }
                    
                    .context-item {
                        padding: var(--space-2) var(--space-3);
                        cursor: pointer;
                        border-radius: var(--radius-sm);
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        font-size: var(--text-sm);
                        color: var(--text-primary);
                    }
                    
                    .context-item:hover {
                        background: var(--accent-primary);
                        color: white;
                    }
                    
                    .context-separator {
                        height: 1px;
                        background: var(--border-primary);
                        margin: var(--space-2) 0;
                    }
                    
                    .shortcut {
                        font-size: var(--text-xs);
                        color: var(--text-muted);
                        font-family: var(--font-mono);
                    }
                    
                    .context-item:hover .shortcut {
                        color: rgba(255, 255, 255, 0.8);
                    }
                `;
                document.head.appendChild(contextStyle);
            }
            
            // Position and show context menu
            contextMenu.style.left = e.pageX + 'px';
            contextMenu.style.top = e.pageY + 'px';
            contextMenu.style.display = 'block';
            
            // Hide context menu on click outside
            const hideContextMenu = (event) => {
                if (!contextMenu.contains(event.target)) {
                    contextMenu.style.display = 'none';
                    document.removeEventListener('click', hideContextMenu);
                }
            };
            
            setTimeout(() => {
                document.addEventListener('click', hideContextMenu);
            }, 10);
        });

        // Add mouse wheel zoom support with Ctrl key
        document.addEventListener('wheel', (e) => {
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                const viewer = window.prismViewer;
                if (viewer && viewer.handleWheel) {
                    viewer.handleWheel(e);
                }
            }
        }, { passive: false });

        // Store viewer instance globally for external access
        window.addEventListener('DOMContentLoaded', () => {
            window.prismViewer = new PRISMViewer();
        });

        // Add fullscreen support
        document.addEventListener('keydown', (e) => {
            if (e.key === 'F11') {
                e.preventDefault();
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                } else {
                    document.documentElement.requestFullscreen();
                }
            }
        });

        // Handle fullscreen changes
        document.addEventListener('fullscreenchange', () => {
            const viewer = window.prismViewer;
            if (viewer) {
                // Recalculate fit to screen when entering/exiting fullscreen
                setTimeout(() => {
                    viewer.fitToScreen();
                }, 100);
            }
        });

        // Add window resize handler
        window.addEventListener('resize', () => {
            const viewer = window.prismViewer;
            if (viewer) {
                // Debounce resize handling
                clearTimeout(viewer.resizeTimeout);
                viewer.resizeTimeout = setTimeout(() => {
                    viewer.fitToScreen();
                }, 250);
            }
        });

        // Add performance monitoring
        window.addEventListener('load', () => {
            console.log('PRISM Viewer loaded in', performance.now().toFixed(2), 'ms');
            
            // Monitor performance
            if ('PerformanceObserver' in window) {
                const observer = new PerformanceObserver((list) => {
                    const entries = list.getEntries();
                    entries.forEach((entry) => {
                        if (entry.duration > 100) {
                            console.warn(`Slow operation detected: ${entry.name} took ${entry.duration.toFixed(2)}ms`);
                        }
                    });
                });
                
                observer.observe({ entryTypes: ['measure', 'navigation'] });
            }
        });

        // Add error boundary for uncaught errors
        window.addEventListener('error', (e) => {
            console.error('Uncaught error in PRISM Viewer:', e.error);
            
            // Show user-friendly error message
            const viewer = window.prismViewer;
            if (viewer) {
                viewer.showStatus(`Application Error: ${e.error.message}`, true);
            }
        });

        // Add unhandled promise rejection handler
        window.addEventListener('unhandledrejection', (e) => {
            console.error('Unhandled promise rejection in PRISM Viewer:', e.reason);
            
            const viewer = window.prismViewer;
            if (viewer) {
                viewer.showStatus(`Promise Error: ${e.reason}`, true);
            }
        });
    </script>
</body>
</html>